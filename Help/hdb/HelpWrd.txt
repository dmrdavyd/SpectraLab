: +TAB ( --- ) 
: -TAB ( --- ) 
: 0TAB ( -- ) 
\ left margin goes to left edge of screen
DEFER >BOLD 
DEFER >NORM 
: ?CONTROL ( -- f1 ) 
\ return true if control is down
: ?LINE ( n1 -- ) 
: ?SHIFT ( -- f1 ) 
\ return true if shift is down
: AT-XY ( x y -- ) 
\ synonym of GOTOXY (ANS version of GOTOXY)
DEFER BEEP 
: BEEP! ( frequency duration-ms -- ) 
: COLS ( -- n1 ) 
\ current screen columns
: CONDC ( -- dc ) 
\ get the console device context
DEFER CONHNDL 
: CRTAB ( -- ) 
CONSTANT DOUBLE_MASK \ double click mask
CONSTANT DOWN_MASK \ mouse down mask
: EKEY>CHAR ( u -- u false | char true ) 
\ returns TRUE if displayable character
: EKEY>FKEY ( u1 -- u2 flag ) 
SYNONYM EKEY? KEY? ( -- flag ) 
SYNONYM EKEY? KEY? ( -- flag ) 
CONSTANT EMIT? ( -- flag ) 
\ return TRUE if its ok to emit a character
: FIRST-LINE ( -- ) 
\ set first line flag
VALUE FIRST-LINE? \ is this the first line of a paragraph
: FOCUS-CONSOLE ( -- ) 
CONSTANT FUNCTION_MASK \ function key maks
: HIDE-CONSOLE ( -- ) 
\ saveconx ?exit
\ getcolrow to savecony to saveconx
( SW_HIDE ) 
VALUE INDENT \ indent/outdent spaces
CONSTANT K-ALT-MASK \ alt key mask
CONSTANT K-ALT-MASK \ alt key mask
CONSTANT K-CTRL-MASK \ control key mask
CONSTANT K-CTRL-MASK \ control key mask
VALUE LEFT-MARGIN 
CONSTANT MENU_MASK \ menu operations
CONSTANT MOUSE_MASK \ mouse operations
: NORMAL-CONSOLE ( -- ) 
\ un-minimizes a minimized console window
( SW_NORMAL ) 
: PAGE ( -- ) 
\ skip to next page (PRINTER) clear screen (CONSOLE)
CONSTANT PROC_MASK \ procedure base mask
VALUE RIGHT-MARGIN 
: ROWS ( -- n1 ) 
\ current screen rows
: SET-CONPOS ( x y -- ) 
\ set the console position
: SHIFTMASK ( -- mask ) 
SYNONYM SHIFT_MASK K-SHIFT-MASK 
SYNONYM SHIFT_MASK K-SHIFT-MASK 
: SHOW-WINDOW ( n -- ) 
CONSTANT SPECIAL_MASK \ special keyboard key mask
: TAB ( -- ) 
VALUE TAB-MARGIN 
VALUE TAB-SIZE 
: TAB-WRAP? ( n1 -- f1 ) 
\ return true if column exceeds the maximum
\ desired tabs, or crosses into the right
\ margin area
SYNONYM TABBING-OFF tabing-off 
SYNONYM TABBING-OFF tabing-off 
SYNONYM TABBING-ON tabing-on 
SYNONYM TABBING-ON tabing-on 
VALUE TABING? \ are we tabing, default to no
VALUE TABS-MAX 
: TONE ( frequency duration-ms -- ) 
VARIABLE TONE_DURA 
VARIABLE TONE_FREQ 
: UNHIDE-CONSOLE ( -- ) 
\ saveconx 0= ?exit
( SW_SHOW ) 
: UNHIDE-CONSOLE ( -- ) 
\ saveconx 0= ?exit
( SW_SHOW ) 
CONSTANT UP_MASK \ mouse up mask
: WRAP? ( n1 -- f1 ) 
\ return true if column n1 crosses into the
\ right margin area
: _BEEP ( -- ) 
CODE ! ( n1 a1 -- ) 
\ store cell n1 into address a1
: !CSP ( -- ) 
\ save current stack pointer for later stack depth check
CODE "#HASH ( a1 n1 #threads -- n2 ) 
: ", ( a1 n1 -- ) 
\ compile string a1,n1 as a counted string at here
: "CLIP" ( c-addr1 len1 -- c-addr2 len2 ) 
\ W32F           String Extra
\ Clip string c-addr1,len1 to c-addr2,len2 where c-addr2=c-addr1 and
\ len2 is between 0 and MAXCOUNTED.
CODE "FIND-PROC ( addr len -- proccfa -1 | 0 ) 
\ find windows proc by name **WINED**
: "FLOAD \ synonym of INCLUDED
: "HEADER ( a1 n1 -- ) 
\ build header in same dict as wordlist
DEFER "OPEN ( a1 n1 -- fileid f1 ) 
\ open filename a1,n1  ( but not in editor )
DEFER "PUSHKEYS 
: "TO-PATHEND" ( a1 n1 --- a2 n2 ) 
\ return a2 and count=n1 of filename
: "WINLIBRARY ( adr len -- ) 
CODE # ( d1 -- d2 ) 
\ convert a digit in pictured number output - see <#
: #(;CODE) ( a1 -- ) 
CONSTANT #-LOCALS \ must match code above!!!!
: #> ( d1 -- addr len ) 
\ ends a pictured number output - see <#
: #DOES> ( -- ) 
\ "compile time"
( a1 -- ) 
\ "runtime" a1=cfa of word being defined
: #S ( d1 -- d2 ) 
\ consume last digits in a pictured number output - see <#
: #TAB ( n1 -- ) 
CONSTANT #TIB \ address of terminal input buffer length
CONSTANT #VOCS \ Maximum number of vocabularies in search order
: $CURRENT-DIR! ( a1 -- f1 ) 
\ a1 is a null terminated directory string
: $FLOAD ( a1 -- ) 
\ a1 = counted file string
: $OPEN ( addr -- fileid f1 ) 
\ open counted filename specified by addr
\ return fileid and f1=false=ok
USER &EXCEPT 
USER &EXREC 
VALUE &FORTHDIR \ The Win32Forth installation directory
\ (in turnkey applications it's the path of the exe-file).
: &OF ( "name" -- addr ) 
\ get the address of a value or local
VALUE &PROGNAM \ The program name buffer
\ (the name of the exe-file including the full path).
DEFER &THE-SCREEN 
: ' ( "name" -- cfa ) 
\ get cfa of parsed word
: ("HEADER) ( a1 n1 -- ) 
NCODE (&OF-LOCAL) ( -- addr ) 
\ get address of local following
NCODE (&OF-VALUE) ( -- addr ) 
\ push the literal value following onto the data stack
NCODE ((")) ( -- counted-string ) 
: ((VERSION)) ( version# -- addr len ) 
NCODE (+LOOP) ( n1 -- ) 
\ "runtime" bump count by n1 and branch to
\ after DO if loop count not complete
NCODE (.") ( -- addr len ) 
\ for ."
: (;CODE) ( -- ) 
NCODE (?DO) ( n1 n2 -- ) 
\ "runtime" setup loop using n1,n2, if n1=n2
\ then discard n1,n2 and branch to after DO
: (ABORT") ( f -- ) 
NCODE (C") ( -- addr ) 
\ for c" type strings
: (D.) ( d -- addr len ) 
\ convert as signed double to ascii string
NCODE (DO) ( n1 n2 -- ) 
\ "runtime" setup loop using n1,n2
: (DOES>) ( -- ) 
: (DPRWARN) ( f -- f ) 
\ warn if deprecated word was found
: (IS) ( xt -- ) 
: (LOCAL) ( addr cnt -- ) 
\ create name in LOCALS vocab
NCODE (LOOP) ( -- ) 
\ "runtime" bump count and branch to after
\ DO if loop count not complete
DEFER (MEMLOCK) 
DEFER (MEMUNLOCK) 
: (NUMBER?) ( addr len -- d1 f1 ) 
NCODE (S") ( -- addr len ) 
\ for s" type strings
NCODE (SEARCH-SELF) ( addr len wid -- 0 | cfa flag ) 
\ uses VSRCH to search this wordlist
CODE (SEARCH-WID) ( addr len voc -- 0 | cfa bfa ) 
\ this is the standard vocab vsrch
\ returns bfa = 1 for immediate words, and
\ bfa = -1 for "normal" words
CREATE (SOURCE) \ input stream pointer
: (WINPAUSE) 
NCODE (Z") ( -- addr ) 
\ for z" type strings
CODE * ( n1 n2 -- n3 ) 
\ multiply n1 by n2, return single result n3
: */ ( n1 n2 n3 -- quotient ) 
\ same as */MOD but gives only quotient
CODE */MOD ( n1 n2 n3 -- remainder quotient ) 
\ integer single multiply and divide:
\ give remainder and quotient of [n1*n2]/n3. Intermediate result n1*n2
\ is a double, so there is no overflow.
CODE + ( n1 n2 -- n3 ) 
\ add n1 to n2, return sum n3
CODE +! ( n1 a1 -- ) 
\ add cell n1 to the contents of address a1
CODE +CELLS ( n1 a1 -- n1*cell+a1 ) 
\ multiply n1 by the cell size and add
\ the result to address a1
: +LOOP 
CODE +NULL ( c-addr -- ) 
\ W32F        String Extra
\ Append a NULL to the counted string.
CODE +PLACE ( c-addr1 len1 c-addr2 -- ) 
\ W32F    String Extra
\ Append string addr1,len1 to the counted string at addr2.
: +TO ( n -<value_name>- ) 
\ Add to a value as in
\ 10 VALUE X  then  20 +TO X  sets X to 30
: +TO ( n -<value_name>- ) 
\ Add to a value as in
\ 10 VALUE X  then  20 +TO X  sets X to 30
: , ( n -- ) 
( compile cell at HERE, increment DP) 
: ," ( -<string">- ) 
\ compile string delimited by " as a counted string at here
CODE - ( n1 n2 -- n3 ) 
\ subtract n2 from n1, return difference n3
 -1 
NCODE -?BRANCH ( f1 -- fl ) 
\ non-destructive "runtime" for branch on f1=FALSE
CODE -ALIGNED ( addr1 -- addr2 ) 
CONSTANT -CELL 
CODE -CELLS ( n1 a1 -- a1-n1*cell ) 
\ multiply n1 by the cell size and
\ subtract the result from address a1
: -IF 
: -NULLS ( c-addr u1 -- c-addr u2 ) 
\ W32F          String Extra
\ If u1 is greater than zero, u2 is equal to u1 less the number of nulls at
\ the end of the character string specified by c-addr u1. If u1 is zero or the
\ entire string consists of nulls, u2 is zero.
CODE -ROT ( n1 n2 n3 -- n3 n1 n2 ) 
\ rotate top of data stack to third item
CODE -SCAN ( addr len char -- addr' len' ) 
\ Scan for char BACKWARDS starting
\ at addr, the end of the string, back through len bytes before addr,
\ returning addr' and len' of char.
CODE -SKIP ( addr len char -- addr' len' ) 
\ Skip occurances of char BACKWARDS
\ starting at addr, the end of the string, back through len bytes
\ before addr, returning addr' and len' of char.
CODE -TRAILCHARS ( c-addr u1 char -- c-addr u2 ) 
\ W32F          String Extra
\ If u1 is greater than zero, u2 is equal to u1 less the number of chars at
\ the end of the character string specified by c-addr u1. If u1 is zero or the
\ entire string consists of chars, u2 is zero.
: -TRAILING ( c-addr u1 -- c-addr u2 ) 
\ ANSI          String
\ If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
\ the end of the character string specified by c-addr u1. If u1 is zero or the
\ entire string consists of spaces, u2 is zero.
VALUE -VE-NUM? \ negate value flag
: . ( n -- ) 
\ display as signed single
: ." \ comp: ( -<string">- ) run: ( -- ) \ See also  s"  and  .(
\ Compiletime: Parses the input stream until it finds the next " and
\ compiles it into the current definition.
\ Runtime: Prints the compiled text to the console window
: .( ( -- ) 
\ - interpretation only -  ( see also  ."  and  S" )
\ parses the input stream until it finds the next ) and
\ prints the text beetween .( and ) in the console window
: .ID ( nfa -- ) 
\ display header's name
: .NAME ( xt -- ) 
\ show name, if can't find name, show address
: .R ( n w -- ) 
\ display as signed single right justified in w wide field
DEFER .REFILL 
: .S ( -- ) 
\ display current data stack contents
CREATE .SMAX 
: .VERSION ( -- ) 
: / ( n1 n2 -- quot ) 
\ integer single divide : quotient
CODE /MOD ( n1 n2 -- rem quot ) 
\ integer signed single divide with remainder & quotient
: /PARSE ( -- addr u ) 
: /PARSE-S$ ( -- a1 ) 
\ parse possibly quoted string
: /PARSE-WORD ( -- a1 ) 
CODE /STRING ( c-addr1 u1 n -- c-addr2 u2 ) 
\ ANSI   String
\ Adjust the character string at c-addr1 by n characters. The resulting character
\ string, specified by c-addr2 u2, begins at c-addr1 plus n characters and is u1
\ minus n characters long. 
\ If n1 greater than len1, then returned len2 will be zero. 
\ For early (pre Nov 2000) versions of W32F, if n1 less than zero,
\ then returned length u2 was zero.
\ /STRING is used to remove or add characters relative to the left end of the
\ character string. Positive values of n will exclude characters from the string
\ while negative values of n will include characters to the left of the string.
 0 
CODE 0< ( n1 -- f1 ) 
\ return true if n1 is less than zero
CODE 0<> ( n1 -- f1 ) 
\ return true if n1 is not equal to zero
CODE 0= ( n1 -- f1 ) 
\ return true if n1 equals zero
CODE 0> ( n1 -- f1 ) 
\ return true if n1 is greater than zero
CODE 0MAX ( n1 -- n2 ) 
\ return n2 the greater of n1 and zero
 1 
CODE 1+ ( n1 -- n2 ) 
\ add one to n1
CODE 1- ( n1 -- n2 ) 
\ subtract one from n1
 2 
CODE 2! ( d1 a1 -- ) 
\ store the double number d1 into address a1
CODE 2* ( n1 -- n2 ) 
\ multiply n1 by two
CODE 2/ ( n1 -- n2 ) 
\ signed divide n1 by two
CODE 2>R ( n1 n2 -- ) 
( R: -- n1 n2 ) 
\ push two items onto the returnstack
CODE 2@ ( a1 -- d1 ) 
\ fetch the double number d1 from address a1
: 2CONSTANT ( n1 n2 -- ) 
\ create a double constant
CODE 2DROP ( n1 n2 -- ) 
\ discard two single items - one double - from the data stack
CODE 2DUP ( n1 n2 -- n1 n2 n1 n2 ) 
\ duplicate the top two single items
\ on the data stack
CODE 2NIP ( n1 n2 n3 n4 -- n3 n4 ) 
\ discard third and fourth items from data stack
CODE 2OVER ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 n2 ) 
\ copy second double on top
CODE 2R> ( -- n1 n2 ) 
( R: n1 n2 -- ) 
\ pop two items off the return stack
CODE 2R@ ( -- n1 n2 ) 
\ get a copy of the top two items on the return stack
CODE 2ROT ( n1 n2 n3 n4 n5 n6 -- n3 n4 n5 n6 n1 n2 ) 
\ rotate 3 double
CODE 2SWAP ( n1 n2 n3 n4 -- n3 n4 n1 n2 ) 
\ exchange the two topmost doubles
: 2VARIABLE ( "name" -- ) 
\ create a double variable
CODE 3DROP ( n1 n2 n3 -- ) 
\ discard three items from the data stack
CODE 3DUP ( n1 n2 n3 -- n1 n2 n3 n1 n2 n3 ) 
\ duplicate 3 topmost cells
CODE 3REVERSE ( n1 n2 n3 -- n3 n2 n1 ) 
\ exchange first and third items on data stack
CODE 4DROP ( n1 n2 n3 n4 -- ) 
\ discard four items from the data stack
CODE 4DUP ( a b c d -- a b c d a b c d ) 
\ duplicate 4 topmost cells
CODE 4REVERSE ( n1 n2 n3 n4 -- n4 n3 n2 n1 ) 
\ exchange first and fourth plus second and
\ third items on the data stack
 : 
: :NONAME ( -- xt ) 
\ start a headerless colon definition
: ; ( -- ) 
CODE < ( n1 n2 -- f1 ) 
\ return true if n1 is less than n2
: <# ( ud -- ) 
\ begin a pictured number output. Full example :
\ : test dup 0< if negate -1 else 0 then >r
\ s>d <# [char] $ hold # # [char] . hold # # # [char] , hold #S r> sign #>
\ cr type ;
\ 1234599 test    displays    12,345.99$
\ -1234599 test    displays   -12,345.99$
CODE <= ( n1 n2 -- f1 ) 
\ return true if n1 is less than n2
CODE <> ( n1 n2 -- f1 ) 
\ return true if n1 is not equal to n2
: <MARK ( -- addr ) 
: <RESOLVE ( addr -- ) 
CODE = ( n1 n2 -- f1 ) 
\ return true if n1 is equal to n2
CODE > ( n1 n2 -- f1 ) 
\ return true if n1 is greater than n2
CODE >= ( n1 n2 -- f1 ) 
\ return true if n1 is greater than n2
: >APPLICATION ( -- ) 
\ select app dict, save prev dict
CODE >BODY ( cfa -- pfa ) 
\ convert code field address to parameter field address
: >CODE ( -- ) 
\ select code dict, save prev dict
: >DP ( dp -- ) 
\ save the current DP, set new
: >FFA@ ( cfa -- ffa ) 
\ get the File Field Address
: >HEAD-FIELD ( cfa mask -- addr  ) 
\ get the optional field's address
VARIABLE >IN \ offset in to input stream
: >MARK ( -- addr ) 
CODE >NAME ( CFA -- NFA  ) 
\ search vocabs for cfa, return nfa
\ Follows the VOC-LINK pointer to all of the vocabularies, searches threads for CFA
\ EBX is CFA to search for. On exit, EBX is NFA
\ Uses: EAX is voc link field, ECX is voc thread fields, EDX is thread link entry
\ If entry is not found, returns NFA of [UNKNOWN]
CODE >NUMBER ( ud addr len -- ud addr len ) 
: >OFA@ ( cfa -- ofa@ ) 
\ get the Optimization Field Address value
CODE >R ( n1 -- ) 
( R: -- n1 ) 
\ push n1 onto the return stack
: >RESOLVE ( addr -- ) 
: >SYSTEM ( -- ) 
\ select sys dict, save prev dict
: >VIEW ( cfa -- vfa ) 
: >VIEW@ ( cfa -- ffa ) 
\ get the View Field Address
: ? ( addr -- ) 
\ display single stored at address
VALUE ?:M 
NCODE ?BRANCH ( f1 -- ) 
\ "runtime" for branch on f1=FALSE
: ?COMP 
DEFER ?CR ( n -- ) 
( stdout: CR if not room for n chars) 
: ?CSP ( -- ) 
\ check current stack pointer against saved stack pointer
: ?DEFEXT ( addr -- ) 
\ conditionally add a default extension
: ?DO 
CODE ?DUP ( n -- n [n] ) 
\ duplicate top of data stack if non-zero
: ?EXEC 
: ?EXIT ( F1 -- ) 
: ?EXIT ( F1 -- ) 
: ?IS ( xt -- xt ) 
\ error if not a deferred word
NCODE ?LEAVE ( f1 -- ) 
\ exit the current DO LOOP if f1=TRUE
: ?MEMCHK ( n1 -- ) 
\ test to see if we have enough memory
: ?MISSING ( f -- ) 
: ?PAIRS ( n1 n2 -- ) 
: ?STACK ( -- ) 
\ check the data stack for stack underflow
NCODE ?THROW ( f n -- ) 
\ SWAP IF THROW ELSE DROP THEN ;
DEFER ?UNSAVE-SRC 
CODE @ ( a1 -- n1 ) 
\ get the cell n1 from address a1
NCODE @(IP) ( -- n ) 
: ABORT ( -- ) 
: ABORT! ( addr -- ) 
\ abort, print counted string passed
: ABORT" ( flag -<ccc>- -- ) 
\ abort and display message ccc if flag is true
CODE ABS ( n -- |n| ) 
\ return the absolute value of n1 as n2
DEFER ACCEPT ( addr nbmax -- nb ) 
( stdin: input line) 
CODE ADD-LINK ( addr list -- ) 
\ W32F         List
\ Add a link to the head of a list.
CREATE ADP 
: ADVANCE-FILE ( len-ud fileid -- ior ) 
\ RELATIVE position file, not ANS \ ior - 0 = success
: AGAIN 
: AHEAD 
: ALIAS ( xt "name" -- ) 
\ W32F
\ Creates an alias of a word that is non-imediate (unless IMMEDIATE is used).
\ NOTE View of either name can go to the synonym instead (it depends which name
\ is found first in a full dictionary search).
: ALIGN ( -- ) 
\ align DP & pad
CODE ALIGNED ( addr1 -- addr2 ) 
\ addr2 is the next cell aligned address following addr1
: ALLOCATE ( u -- addr fl ) 
\ ansi version of malloc
: ALLOT ( n -- ) 
\ allocate n bytes at HERE, increment DP
CODE AND ( n1 n2 -- n3 ) 
\ perform bitwise AND of n1,n2, return result n3
: APP-ALIGN ( -- ) 
: APP-ALLOT ( n1 -- ) 
: APP-FREE ( -- n1 ) 
: APP-HERE ( -- a ) 
CONSTANT APP-OFFS 
: APP-ORIGIN ( -- a1 ) 
CONSTANT APP-SIZE 
CODE APPEND-LINK ( addr list -- ) 
\ W32F         List
\ Append a link to the end of a list.
: APPEND-STRAND ( cfa <-name-> -- ) 
\ add cfa to chain end
VALUE APPINST \ the application instance (origin of code), set in MAIN
: APPLICATION> ( -- ) 
\ back to previous DP  (synonym of DP>)
: ASCII-Z ( addr len buff -- buff-z ) 
\ W32F      String Extra
\ Make a null-terminated copy of string addr len in buff and return the address of the
\ first character.
CONSTANT ASSYNC-TASK 
USER BASE 
: BEGIN 
CODE BETWEEN ( n1 low high -- f1 ) 
\ f1=true if ( (n1 >= low) and (n1 <= high) )
CONSTANT BFA_DEPRECATED \ bit of header's field BFA : true if word is deprecated
CONSTANT BFA_FFA_PRESENT \ bit of header's field BFA : true if file field present
CONSTANT BFA_IMMEDIATE \ bit of header's field BFA : true if word is immediate
CONSTANT BFA_OFA_PRESENT \ bit of header's field BFA : true if optimize field present
CONSTANT BFA_UNUSED1 
CONSTANT BFA_UNUSED2 
CONSTANT BFA_UNUSED3 
CONSTANT BFA_VFA_PRESENT \ bit of header's field BFA : true if view field present
DEFER BG@ ( f b -- ) 
( stdout: get background color) 
: BIN 
: BINARY 
CODE BIT-MSB ( n -- msb ) 
\ most significant bit in n
CODE BIT-POP ( n -- bits-in-n ) 
\ population count of bits in ebx
CONSTANT BL 
NCODE BLANK ( c-addr u -- ) 
\ ANSI         String
\ If u is greater than zero, store the character value for space in u consecutive
\ character positions beginning at c-addr.
CODE BODY> ( pfa -- cfa ) 
\ convert parameter field address to code field address
DEFER BOOT 
CODE BOUNDS ( adr len -- lim first ) 
\ calculate loop bounds from adr,len
NCODE BRANCH ( -- ) 
\ "runtime" for branch always
CONSTANT BUILD# 
DEFER BYE 
CODE BYTE-SORT ( a1 n1 -- ) 
\ perform in place sort buffer a1 of n1 bytes
CODE C! ( c1 a1 -- ) 
\ store character c1 into address a1
: C" \ comp: ( -<string">- ) run: \ ( -- addr )
\ compile a string, delimiteb by " , from input stream. When
\ run, give the string as the address of its count byte
CODE C+! ( c1 a1 -- ) 
\ add character c1 to the contents of address a1
: C, ( n -- ) 
( compile byte at HERE, increment DP) 
CODE C@ ( a1 -- c1 ) 
\ fetch the character c1 from address a1
: CALL ( [args..] -<proc>- result ) 
\ compile or execute a windows procedure
CODE CALL-PROC ( [ n ] ep -- r ) 
\ call ep on top of stack
ASSEMBLER CALLF 
: CAPS-FIND ( str -- str FALSE | cfa flag ) 
: CASE 
: CATCH ( cfa -- flag ) 
\ execute the word given by its cfa in a way that
\ will pass control to the word just after CATCH, whatever an error
\ occurs while cfa is executed or not - see THROW which may be
\ used inside the word "cfa" to handle errors if any.
\ if no error occured, flag is 0, else the flag is given by THROW
\ Beware: if an error occurs, any parameters for the word "cfa" are
\ still on the stack, under "flag"
CODE CDECR ( addr -- ) 
\ decrement the BYTE contents of addr
CREATE CDP 
CONSTANT CELL 
CODE CELL+ ( a1 -- a1+cell ) 
\ add a cell to a1
CODE CELL- ( a1 -- a1-cell ) 
\ subtract a cell from a1
CODE CELL-SORT ( a1 n1 -- ) 
\ perform in place sort buffer a1 of n1 cells
CODE CELLS ( n1 -- n1*cell ) 
\ multiply n1 by the cell size
CODE CELLS+ ( a1 n1 -- a1+n1*cell ) 
\ multiply n1 by the cell size and add
\ the result to address a1
CODE CELLS- ( a1 n1 -- a1-n1*cell ) 
\ multiply n1 by the cell size and subtract
\ the result from address a1
OFFSET CFA>PROC ( addr -- addr ) 
\ offset to proc from cfa
: CFAPTR! ( xt -- ) 
\ set cfaptr to cfa
: CHAIN-ADD ( chain_address -<word_to_add>- ) 
\ Add chain item.
\ For normal forward chains.
: CHAIN-ADD-BEFORE ( chain_address -<word_to_add>- ) 
\ Add chain item
\ For reverse chains like BYE
VARIABLE CHAIN-LINK \ linked list of chains
: CHAIN-REMOVE ( cfa chain_address -- ) 
\ Remove the specified item from the chain.
: CHAR ( "c" -- char ) 
\ parse char from input stream and put its ascii code on stack.
\ If <c> is longer than a char, takes its first char.
\ If parse area is empty return 0.
CODE CHAR+ ( a1 -- a1+char ) 
\ add the characters size in bytes to a1
CODE CHARS ( n1 -- n1*char ) 
\ multiply n1 by the character size (1)
DEFER CHARWH 
CODE CINCR ( addr -- ) 
\ increment the BYTE contents of addr
DEFER CLASS>SYS 
: CLOSE-FILE ( fileid -- ior ) 
DEFER CLS ( -- ) 
( stdout: clear screen) 
: CMDLINE ( -- addr len ) 
\ fetch command line
NCODE CMOVE ( from to count -- ) 
\ move "count" bytes from address "from" to
\ address "to" - start with the first byte of "from"
NCODE CMOVE> ( from to count -- ) 
\ move "count" bytes from address "from" to
\ address "to" - start with the last byte of "from"
: CODE-, ( n -- ) 
: CODE-ALIGN ( -- ) 
: CODE-ALLOT ( n1 -- ) 
: CODE-C, ( n -- ) 
: CODE-FREE ( -- n1 ) 
: CODE-HERE ( -- a ) 
CONSTANT CODE-OFFS 
: CODE-ORIGIN ( -- a1 ) 
CONSTANT CODE-SIZE \ values set in meta compile
: CODE-W, ( n -- ) 
: CODE> ( -- ) 
\ back to previous DP  (synonym of DP>)
: COL ( n -- ) 
\ goto nth column
CODE COMPARE ( adr1 len1 adr2 len2 -- n ) 
\ COMPARE compares two strings. The return value is:
\ 0 = string1 = string2
\ -1 = string1 < string2
\ 1 = string1 > string2
CODE COMPILE ( -- ) 
\ compile xt following
: COMPILE, ( xt -- ) 
\ compile (same as , but with warning)
CREATE CONSFILE 
DEFER CONSOLE ( -- ) 
( stdout: switch I/O to console) 
: CONSTANT ( n "name" -- ) 
\ create a constant (unchangeable) value
VARIABLE CONTEXT 
CODE COUNT ( str -- addr len ) 
\ byte counted strings
DEFER CR ( -- ) 
( stdout: emit carriage return) 
: CREATE ( "<spaces>name" -- ) 
\ Create a definition for name.
: CREATE-FILE ( adr slen fmode -- fileid ior ) 
CREATE CRLF$ 
VARIABLE CSP \ Current Stack Pointer variable
VALUE CUR-FILE \ ptr to CUR-FILE
VARIABLE CURRENT 
: CURRENT-DIR$ ( -- a1 ) 
\ get the full path to the current directory
CODE D+ ( d1 d2 -- d3 ) 
\ add 2 doubles - no overflow check
CODE D- ( d1 d2 -- d3 ) 
\ substract 2 doubles
: D. ( d -- ) 
\ display as signed double
: D.R ( d w -- ) 
\ display as signed double right justified in w wide field
CODE D0< ( d1 -- f1 ) 
\ Signed compare d1 double number with zero.
: D0= ( d -- f) 
\ double compare to 0
CODE D2* ( d1 -- d2 ) 
\ multiply the double number d1 by two
CODE D2/ ( d1 -- d2 ) 
\ divide the double number d1 by two
CODE D< ( d1 d2 -- f ) 
\ Signed compare two double numbers.
: D<> ( d1 d2 -- d ) 
\ Signed compare two double numbers.
: D= ( d1 d2 -- f1 ) 
\ f1=true if double d1 is equal to double d2
: D> ( d1 d2 -- f ) 
\ Signed compare two double numbers.
: D>S ( d -- s ) 
\ convert double to single
CODE DABS ( d1 -- d2 ) 
\ return the absolute value of d1 as d2
: DECIMAL 
CODE DECR ( addr -- ) 
\ decrement the contents of addr
: DEFER ( "name" -- ) 
\ create a deferred execution function, defaults to a NOOP
\ Typical usage    ' new-action is deferred-action
\ -or- : new-word ['] new-action is deferred-action ;
\ See also: is-default restore-default action-of defer@ defer!
VARIABLE DEFER-LIST \ The head of a linked-list of deferred words
: DEFEXT ( -<F>- ) 
\ make -<F>- the default extension
CREATE DEFEXT$ ( -- a1 ) 
\ the default extension buffer (max 8 chars)
CONSTANT DEFEXTMAX 
CREATE DEFEXTZ$ ( -- a1 ) 
\ copy, with . and null terminated
VARIABLE DEFEXT_ON? \ January 17th, 2000 - 10:31 added to better
: DEFINED ( -- str 0 | cfa flag ) 
CREATE DELAYS 
: DELETE-FILE ( adr len -- ior ) 
\ ior - 0 = success
: DEPRECATED ( -- ) 
\ mark the last header created as a deprecated word
CODE DEPTH ( -- n ) 
\ return the current data stack depth (n excluded)
CODE DIGIT ( char base -- n flag ) 
: DLL ( 'name.DLL' <-name-> ) 
\ usage: DLL "USER32.DLL" USER32
: DMAX ( d1 d2 -- d3 ) 
\ Replace with the larger of the two (signed).
: DMIN ( d1 d2 -- d3 ) 
\ Replace with the smaller of the two (signed).
CODE DNEGATE ( d1 -- d2 ) 
\ negate d1, returning 2's complement d2
: DO 
DEFER DO-;CHAIN 
: DO-CHAIN ( chain_address -- ) 
\ Execute all words in a chain.
: DO-LINK ( i*x xt list -- j*x ) 
\ W32F        List
\ Apply input function, xt to each element of the list in turn. i*x and j*x are the
\ input(s) to and output(s) of xt (normally the number of inputs=number of outputs).
\ Usage: [parms] ' x link do-link 
\ Follows link, for each link executes x. x must have a stack picture
\ ( [parms ...] link -- [parms ...] ).
\ Safe to use even if x destroys next link and can be used recursively.
ASSEMBLER DO2VALUE 
ASSEMBLER DOCALL 
ASSEMBLER DOCALL-MULTI 
ASSEMBLER DOCALL-SINGLE 
ASSEMBLER DOCOL 
ASSEMBLER DOCON 
ASSEMBLER DODEFER 
ASSEMBLER DODOES 
: DODOES-CALL, ( -- ) 
\ compile call to does> (in code-only section)
: DOES> ( -- ) 
: DOES>? ( ip -- flag ) 
\ is cfa a does> section of code
ASSEMBLER DOEXTERN 
VALUE DOFCON 
CONSTANT DOLOCAL 
CONSTANT DOLOCAL! 
CONSTANT DOLOCAL+! 
ASSEMBLER DOOFF 
VARIABLE DOSCHAR 
VALUE DOUBLE? \ double value
ASSEMBLER DOUSER 
ASSEMBLER DOVALUE 
ASSEMBLER DOVALUE! 
ASSEMBLER DOVALUE+! 
ASSEMBLER DOVAR 
ASSEMBLER DOVOC 
VALUE DP \ data pointer defaults to app space
VARIABLE DP-LINK \ list of xDP structures
VALUE DP-LOCATION \ decimal point location
: DP> ( -- ) 
\ back to previous DP
: DPR-WARNING-OFF ( -- ) 
\ disable warning for use of deprecated words
: DPR-WARNING-ON ( -- ) 
\ enable warning for use of deprecated words
VALUE DPR-WARNING? 
CODE DROP ( n -- ) 
\ discard top entry on data stack
CODE DU< ( ud1 ud2 -- f1 ) 
\ return true if unsigned double ud1 is
\ less than unsigned double ud2
CODE DUP ( n -- n n ) 
\ duplicate top entry on data stack
: DUP-WARNING-OFF ( -- ) 
\ disable warning for redefinitions
: DUP-WARNING-ON ( -- ) 
\ enable warning for redefinitions
VALUE DUP-WARNING? 
CODE DUP>R ( n1 -- n1 ) 
( R: -- n1 ) 
\ push a copy of n1 onto the return stack
: D_ACCEPT ( c-addr nbmax -- nbread ) 
\ accept a string
: D_CR ( -- ) 
\ emit a carriage return
: D_EKEY ( -- u ) 
\ get extended char
: D_EKEY>CHAR ( u -- u false | char true ) 
\ is char ?
: D_EMIT ( char -- ) 
\ emit a character
: D_INIT-CONSOLE ( -- flg ) 
\ init kernel's DOS console, ff if already inited
: D_KEY ( -- char ) 
\ get key from keyboard
: D_KEY? ( -- flag ) 
\ is a char (ie key pressed) available ?
: D_TYPE ( addr cnt -- ) 
\ type a string
: D_UNINIT-CONSOLE ( -- ) 
\ free the character-mode console
VARIABLE ECHO \ ECHO ON echos everything to the console that's included
DEFER EDIT-ERROR 
: ELSE 
DEFER EMIT ( char -- ) 
( stdout: display char) 
: EMIT. ( n -- ) 
: EMPTY-COMMAND-LINE ( -- ) 
DEFER END-INCLUDE 
: ENDCASE 
: ENDIF 
: ENDOF 
NCODE ERASE ( addr u -- ) 
\ ANSI        Core Ext
\ If u is greater than zero, clear all bits in each of u consecutive address
\ units of memory beginning at addr .
: EVALUATE ( addr len -- ) 
\ interpret string addr,len
USER EXC-ACCESS 
USER EXC-GUARD 
ASSEMBLER EXCEPT-HANDLER 
CONSTANT EXCEPT-VALLOC \ points at VirtualAlloc ep
ASSEMBLER EXEC-SEQ 
NCODE EXECUTE ( cfa -- ) 
\ execute a Forth word, given its cfa
: EXECUTE-PARSING ( addr len xt -- ... ) 
ASSEMBLER EXEM 
: EXTERN ( "name" -- ) 
\ extern var
CONSTANT FALSE 
DEFER FG@ ( -- f ) 
( stdout: get foregroung color) 
DEFER FGBG! ( f b -- ) 
( stdout: set back and fore colors) 
: FIELD+ ( n1 n2 <-name-> -- n3 ) 
\ compiling n3=n1+n2 stored offset=n1
( addr1 -- addr2 ) 
\ runtime addr2=addr1+n1
: FILE-APPEND ( fileid -- ior ) 
\ ior - 0 = success
: FILE-POSITION ( fileid -- len-ud ior ) 
: FILE-SIZE ( fileid -- len-ud ior ) 
: FILE-STATUS ( adr len -- x ior ) 
#VOCABULARY FILES \ files vocab
NCODE FILL ( addr len char -- ) 
\ fill addr with char for len bytes
DEFER FIND ( str -- str 0 | cfa flag ) 
VALUE FIND-BUFFER \ ptr to FIND-BUFFER
: FLOAD ( -<filename>- ) 
\ load "filename" into application dictionary
: FLUSH-FILE ( fileid -- ior ) 
CODE FM/MOD ( d n -- rem quot ) 
VOCABULARY FORTH \ main vocabulary
\ #PTHREADS #LEXICON    PROCS             \ procs vocabulary; there's only 1
VOCABULARY FORTH \ main vocabulary
\ #PTHREADS #LEXICON    PROCS             \ procs vocabulary; there's only 1
CODE FPARMS-FP ( len-ud fileid move --  \ parms for file-position words using SetFilePointer \                -- MoveHigh move ptrMoveHigh MoveLow fileid ) 
\ results
\ ptr points here:   ^
: FREE ( addr -- f1 ) 
\ release the memory pointer
\ f1=TRUE=failed, f1=FALSE=ok
: FREE-DLL ( lib-entry -- ) 
\ free a lib entry
: FSAVE-FILE ( addr len filename -- ) 
DEFER GET-CURSOR 
DEFER GETCOLROW 
: GETLASTWINERR ( -- n ) 
\ get windows error code
: GETLASTWINERRMSG ( n -- addr ) 
\ build string for error message
DEFER GETROWOFF ( -- n ) 
( first visible row in new console) 
DEFER GETXY ( -- x y ) 
( stdout: get cursor position) 
DEFER GOTOXY ( x y -- ) 
( stdout: set cursor to x,y) 
: H. ( u -- ) 
\ display as signed single in hexadecimal whatever BASE is
: H.2 ( n1 -- ) 
: H.4 ( n1 -- ) 
: H.8 ( n1 -- ) 
: H.N ( n1 n2 -- ) 
\ display n1 as a HEX number of n2 digits
: H.R ( n1 n2 -- ) 
\ display n1 as a hex number right
\ justified in a field of n2 characters
USER HANDLER 
: HEADER ( "name" -- ) 
\ build a header
: HERE ( -- a1 ) 
( current dictionary pointer, points to next free space) 
: HEX 
#VOCABULARY HIDDEN \ hidden words
\ -------------------- Vocabulary dictionary structure ----------------------
\ [ cfa field        ] +0           VCFA = vocabulary cfa -> DOES> code
\ [ num voc threads  ] +4           #THREADS
\ [ voc link         ] +8           VLINK
\ [ voc header       ] +12          VHEAD
\ [ voc search       ] +16          VSRCH
\ [ voc iterate      ] +20          VITER
\ [ voc thread 0     ] +24          VOC thread 0 = voc-address
\ [ voc thread 1     ] +28          VOC thread 1
\ [ voc thread 2     ] +32          VOC thread 2
\ [ voc thread ...   ] +n*4+24      VOC thread n
: HIDE ( -- ) 
USER HLD 
CODE HOLD ( char -- ) 
\ insert char in number output picture - see <#
CODE I ( -- u ) 
\ push u, the value of the current loop index
CODE I' ( -- u ) 
\ push u, the value of the current loop limit
: IF 
VALUE IGNORE-MISSING-PROCS? \ used to ignore entry point missing, default is load now
\ -------------------- Required PROCs ---------------------------------------
CONSTANT IMG-ENTRY \ -------------------- Compiling words ----------------------------
\ DP is the current data pointer, DP @ is the equivalent of HERE
\ 
\ Each set of pointers to a data ("dictionary") space is a structure.
\ These structures MUST RESIDE IN THE APPLICATION SPACE if they are linked
\ 
\ CELL OFFSET  FUNCTION
\ ---- ------  --------
\ 0     0     Current pointer to area
\ 1     4     Address of the area (origin)
\ 2     8     Highest address of area (origin + length)
\ 4    16     Link of all the xDP areas; set in DP-LINK
\ 5    20     Counted name of the area
\ 
\ 3 defined by default; APP -- std area, SYS -- system area, not saved on
\ TURNKEY and CODE -- area for executable x86 code.
\ 
\ Actual values for these 3 are filled in by the meta compiler.
\ See also PDP and LDP (procs and locals data respectively)
: IMMEDIATE ( -- ) 
\ mark the last header created as an immediate word
: IN-APPLICATION ( -- ) 
\ w32f
\ Activate the application data area.
: IN-CODE ( -- ) 
\ w32f
\ Activate the code data area.
: IN-PREVIOUS ( -- ) 
\ w32f
\ Restore the data area after a call to IN-APPLICATION IN-SYSTEM or IN-CODE.
: IN-SYS? ( -- f ) 
: IN-SYSTEM ( -- ) 
\ w32f
\ Activate the system data area.
: INCLUDE \ synonym of FLOAD
: INCLUDE-FILE ( fileid -- ) 
\ load file open on "fileid" to current dictionary
: INCLUDED ( addr len -- ) 
\ load file addr,len into current dictionary
VALUE INCLUDING? 
CODE INCR ( addr -- ) 
\ increment the contents of addr
VALUE INH \ console input handle
DEFER INIT-CONSOLE 
NCODE INIT-LOCALS ( loc1 loc2 ... -- ) 
DEFER INIT-SCREEN 
VALUE INPARMS \ number of input parameters (locals)
CREATE INP_REC 
: INSERT-STRAND ( cfa <-name-> -- ) 
\ add cfa to chain start
DEFER INTERPRET 
CODE INVERT ( n1 -- n2 ) 
\ perform a bitwise -1 XOR on n1, return result n2
: IS ( xt "name" -- ) 
\ assign xt to a defer
: ISABSOLUTEPATH? ( a1 n1 -- f ) 
\ returns true if path is absolute
CODE ISTR= ( adr1 len1 adr2 len2 -- flag ) 
\ compares two strings, case insensitive, true if equal
CODE J ( -- u ) 
\ push u, the value of the outer loop index
CODE J' ( -- u ) 
\ push u, the value of the outer loop limit
CODE K ( -- u ) 
\ push u, value of the second outer loop index
CODE K' ( -- u ) 
\ push u, the value of the second outer loop limit
KERNEL32.DLL K32DLL 
CONSTANT KERNFILE \ kernel file
DEFER KEY ( -- k ) 
( stdin: get a key ) 
DEFER KEY ( -- k ) 
( stdin: get a key ) 
: KWORDS ( -- ) 
\ simple version of words
: K_BYE ( -- ) 
\ Exit Forth
: K_NOOP0 
: K_NOOP1 
: K_NOOP2 
OFFSET L>NAME ( lfa -- nfa ) 
\ Convert link address to name address.
CODE LARGEST ( a1 n1 --- a2 n2 ) 
VARIABLE LAST \ NFA of last header created
VALUE LAST-ERROR \ last forth error reported
VARIABLE LAST-LINK \ address of last link for last header created
VARIABLE LATEST-NFA 
VARIABLE LATESTXT 
CREATE LCASETAB \ LOWERcase a thru z to A thru Z
CODE LCOUNT ( str -- addr len ) 
\ long (4 bytes) counted strings
NCODE LEAVE ( -- ) 
\ unconditionnaly exit the current DO LOOP
VALUE LEN-PREV 
OFFSET LIB>HANDLE ( addr -- addr ) 
\ offset from link to pfa
OFFSET LIB>NAME ( addr -- addr ) 
\ offset to lib name
: LINK, ( list -- ) 
\ W32F           List
\ Add a link in the dictionary (i.e. at here) to the head of the list.
CODE LINK> ( link -- cfa ) 
\ Convert the link address to the CFA (xt).
OFFSET LINK>HADDR ( addr -- addr' ) 
\ from link to heap address
OFFSET LINK>MEM ( addr -- addr' ) 
\ from link to mem pointer
: LINKFILE ( a1 -- ) 
\ link name a1 as current file IF LOADING ONLY !!
NCODE LIT ( -- n ) 
\ push the literal value following LIT in the
\ dictionary onto the data stack
: LITERAL ( n -- ) 
: LOAD-DLL ( lib-entry -- f1 ) 
\ f1=TRUE if all is ok
VALUE LOADFILE \ pointer to loaded filename
: LOADING? ( -- flag ) 
\ are we loading?
VARIABLE LOADLINE 
LOCAL LOCAL0 
LOCAL LOCAL1 
LOCAL LOCAL10 
LOCAL LOCAL11 
LOCAL LOCAL12 
LOCAL LOCAL13 
LOCAL LOCAL14 
LOCAL LOCAL15 
LOCAL LOCAL2 
LOCAL LOCAL3 
LOCAL LOCAL4 
LOCAL LOCAL5 
LOCAL LOCAL6 
LOCAL LOCAL7 
LOCAL LOCAL8 
LOCAL LOCAL9 
: LOCALALLOC ( n1 -- a1 ) 
\ allocate n1 bytes of return stack
\ return a1 the address of the array
: LOCALALLOC: ( n1 "name" -- ) 
\ allocate a local n1 byte buffer to local "name"
#VOCABULARY LOCALS \ locals vocab
: LOCALS| ( -- ) 
\ ANS standard locals
VALUE LOCFLG \ 1 = compiling args, 0 = compiling locals
: LOOP 
: LOWER ( addr len -- ) 
\ translate string to lowercase
USER LP 
CODE LSCAN ( adr len long -- adr' len' ) 
\ search first occurence of cell "long" in string
CODE LSHIFT ( u1 n -- u2 ) 
\ shift u1 left by n bits (multiply)
CODE LSKIP ( adr len long -- adr' len' ) 
\ skip leading cells "long" in string
CODE M* ( n1 n2 -- d1 ) 
\ multiply n1 by n2, return double result d1
CONSTANT MAIN-TASK 
: MAIN? ( -- f ) 
\ Returns true if this is the main (i.e. console task).
: MALLOC ( u -- addr ) 
\ allocate dynamic memory
CONSTANT MALLOC-ADJLEN \ adjustment for headers + extra cells
CONSTANT MALLOC-HFLAG \ heap flags
VARIABLE MALLOC-LINK \ head of single linked list
CODE MAX ( n1 n2 -- n3 ) 
\ return the greater of n1 and n2
CONSTANT MAX-HANDLE \ maximum length of filename
CONSTANT MAX-PATH \ maximum length of a filename buffer
VALUE MAXASCII \ to support xchar extension
CONSTANT MAXCOUNTED \ maximum length of contents of a counted string
\ -------------------- System WIde Constants --------------------------------
CONSTANT MAXSTRING \ maximum length of a counted string
DEFER MESSAGE 
: MHEAPSIZE ( rel-addr -- n ) 
\ size of abs-addr bytes
CODE MIN ( n1 n2 -- n3 ) 
\ return the lesser of n1 and n2
: MOD ( n1 n2 -- rem ) 
\ integer single divide : remainder
NCODE MOVE ( source dest len -- ) 
\ move len bytes from source address to dest address
ASSEMBLER MOVE-LOCALS 
DEFER MS 
VARIABLE MSG 
OFFSET N>BFA ( nfa -- bfa ) 
\ Convert neme address to the address of the bit fields.
OFFSET N>CFAPTR ( nfa -- cfa-ptr ) 
\ Convert name address to the address of the CFA pointer address.
: N>HEAD ( nfa -- head-fields ) 
OFFSET N>LINK ( nfa -- lfa ) 
\ Convert name address to link address.
: NABORT! ( addr n -- ) 
\ set message, n throw
CODE NALIGNED ( addr n -- addr2 ) 
VALUE NAME-MAX-CHARS \ function names can be this long
CODE NAME> ( nfa -- cfa ) 
\ Convert the name address to the CFA (xt).
CODE NEGATE ( n1 -- n2 ) 
\ negate n1, returning 2's complement n2
DEFER NEW$ 
: NEW-CHAIN ( -- ) 
\ Create a new chain.
: NEW-SYS-CHAIN ( -- ) 
\ Create a new chain in the system space.
: NEWUSER ( size "name" -- ) 
\ Creates a user. A user can be
\ a byte, cell, float, string or stack
ASSEMBLER NEXT-SEQ 
VARIABLE NEXT-USER \ offset of next defineable user variable
: NEXTWORD ( char -- adr flag ) 
\ flag=TRUE if we got a word, else FALSE
: NFA-COUNT ( nfa -- addr count ) 
CODE NIP ( n1 n2 -- n2 ) 
\ discard second item on data stack
CODE NOOP ( -- ) 
\ the Forth no-operation word (does nothing)
: NOOP-CHAIN-ADD ( chain_address -- addr ) 
\ Add chain item, return addr of cfa added.
\ For normal forward chains.
: NOOP-CHAIN-ADD-BEFORE ( chain_address -- addr ) 
\ Add chain item, return addr of cfa added.
\ For reverse chains like BYE
: NUF? ( -- f1 ) 
CONSTANT NULL 
: NUM-INIT ( -- ) 
\ initialise number values
DEFER NUMBER 
DEFER NUMBER, 
: OCTAL 
VALUE ODP \ data pointer defaults to app space
\ ----------------- Switching dictionary words ---------------
\ To switch between data areas, >DP saves and resets the data pointer.
\ NOTE: >DP does a "double UNNEST", so >DP must be the last word in
\ any definition that uses it.
\ 
\ IN-xxxx is used in open code to switch HERE ALLOT , W, etc to point
\ to the specific data area; the current DP is saved in ODP, so
\ it can be reseted using IN-PREVIOUS.
\ 
\ >XXXX and XXXX> move to and from a specific data area, and save the
\ current DP. Should only be used in code, as the return stack is used
\ to save/restore the current value, and must be used in matching pairs.
\ 
: OF 
: OFA-LAST ( -- addr ) 
\ address of last OFA
CODE OFF ( addr -- ) 
\ set the contents of addr of OFF (0)
: OFFSET ( n1 <-name-> -- ) 
\ compiling
( n2 -- n3 ) 
\ runtime n3=n1+n2
: OK ( -- ) 
CODE ON ( addr -- ) 
\ set the contents of addr to ON (-1)
USER OP 
: OPEN-FILE ( adr slen fmode -- fileid ior ) 
CODE OR ( n1 n2 -- n3 ) 
\ perform bitwise OR of n1,n2, return result n3
VALUE OUTH \ console output handle
CODE OVER ( n1 n2 -- n1 n2 n1 ) 
\ copy second item to top of data stack
USER PAD 
: PARMFIND ( addr -- addr FALSE | cfa -1 | cfa 1 ) 
VALUE PARMS \ number of parameters (locals)
: PARMS-INIT ( -- ) 
CODE PARSE ( char "ccc<char>" -- c-addr u ) 
\ parse the input stream
\ for a string delimited by char. Skip ONLY ONE leading char.
\ Give the string as address and count.
ALIAS PARSE-WORD 
ALIAS PARSE-WORD 
CREATE PDP 
NCODE PERFORM ( addr -- ) 
\ execute a Forth word whose cfa is stored at addr
CODE PICK ( ...  k -- ... n[k] ) 
CODE PLACE ( c-addr1 len1 c-addr2 -- ) 
\ W32F           String Extra
\ Place string c-addr1,len1 at c-addr2 as a counted string.
VALUE POCKET \ ptr to POCKET allocated in MAIN
: POSTPONE ( "name" -- ) 
\ compilation only - compile xt of word
: PROC ( #params "name" -- ) 
\ #arguments proc MessageBeep
DEFER PROC-ERROR 
OFFSET PROC>CFA ( addr -- addr ) 
\ offset to proc cfa
OFFSET PROC>EP ( addr -- addr ) 
\ offset to proc ep
OFFSET PROC>LIB ( addr -- addr ) 
\ offset to lib pointer
OFFSET PROC>NAME ( addr -- addr ) 
\ offset to proc name
\ -------------------- Resolving Procedures ---------------------------------
OFFSET PROC>PCNT ( addr -- addr ) 
\ offset to proc count
CREATE PTRNULL 
DEFER PUSHKEY 
: QUERY ( -- ) 
\ accept a line of input from the user to TIB
: QUERY-INTERPRET ( -- ) 
: QUIT ( -- ) 
CONSTANT R/O \ GENERIC_READ
CONSTANT R/W \ READ/WRITE
CODE R> ( -- n1 ) 
( R: n1 -- ) 
\ pop n1 off the return stack
CODE R>DROP ( -- ) 
( R: n1 -- ) 
\ discard one item off of the return stack
CODE R@ ( -- n1 ) 
( R: n1 -- n1 ) 
\ get a copy of the top of the return stack
CODE RDROP ( -- ) 
( R: n1 -- ) 
\ discard one item off of the return stack
: READ-FILE ( b-adr b-len fileid -- len ior ) 
\ ior = 0 = success
: READ-LINE ( adr len fileid -- len eof ior ) 
: REALLOC ( u addr -- addr' fl ) 
: RECURSE ( -- ) 
\ cause current definition to execute itself
: REFILL ( -- f ) 
\ refill TIB from current input stream
: RELEASE ( addr -- ) 
\ release block
: RENAME-FILE ( adr1 len adr2 len -- ior ) 
: REPEAT 
: REPOSITION-FILE ( len-ud fileid -- ior ) 
\ ior - 0 = success
: RES-LOADPROC ( procname lib -- proc-ep | 0 ) 
\ helper to get proc address
: RES-MULTI-LIBS ( proc-cfa -- ) 
\ resolve proc address, search all libs
: RES-SINGLE-LIB ( proc-cfa -- ) 
\ resolve proc address, search the specified lib
DEFER RESET-STACKS 
: RESIZE ( a1 n1 -- a2 f1 ) 
\ ansi version of realloc
: RESIZE-FILE ( len-ud fileid -- ior ) 
: RESTORE-INPUT ( ... 7 -- flag ) 
\ restore input
NCODE RETURNF ( -- ) 
\ internal ITC word for return
: REVEAL ( -- ) 
#VOCABULARY ROOT \ root vocab
CODE ROT ( n1 n2 n3 -- n2 n3 n1 ) 
\ rotate third item to top of data stack
CODE RP! ( a1 -- ) 
\ set the address of the return stack
USER RP0 
CODE RP@ ( -- a1 ) 
\ get a1 the address of the return stack
CODE RSHIFT ( u1 n -- u2 ) 
\ shift u1 right by n bits (divide)
: S" \ comp: ( -<string">- ) run: ( -- addr len )
\ Compiletime: s" parses the input stream until it finds the next " and
\ compiles it into the current definition. Runtime: s" leaves the address
\ and the length of the compiled string on the stack.
CODE S-REVERSE ( n[k]..2 1 0 k -- 0 1 2..n[k] ) 
\ w32f
\ Reverse n items on stack   
\ Usage: 1 2 3 4 5 5 S_REVERSE ==> 5 4 3 2 1
CODE S>D ( n1 -- d1 ) 
\ convert single signed single n1 to a signed
\ double d1
: SAVE-INPUT ( -- ... 7 ) 
\ save input
DEFER SAVE-SRC 
CODE SCAN ( adr len char -- adr' len' ) 
\ search first occurence of char "char" in string
VALUE SCREENDELAY \ delay value for some screen output
DEFER SCROLLTOVIEW 
CREATE SDP 
CODE SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag ) 
\ Search the string specified by c-addr1 u1 for the (sub)string specified by c-addr2 u2.
\ If flag is true, a match was found at c-addr3 with u3 characters remaining.
\ If flag is false there was no match and c-addr3 is c-addr1 and u3 is u1.
: SEARCH-WORDLIST ( addr len wid -- 0 | cfa flag ) 
\ SEARCH-WORDLIST is case insensitive
DEFER SET-CURSOR 
DEFER SETCHARWH 
: SIGN ( f1 -- ) 
\ insert a sign in pictured number output - see <#
CODE SKIP ( adr len char -- adr' len' ) 
\ skip leading chars "char" in string
VALUE SLFACTOR \ adjust this to slow down loading
: SLITERAL ( a1 n1 -- ) 
\ compile string as literal
: SLOW ( -- ) 
CODE SM/REM ( d n -- rem quot ) 
: SOURCE ( -- addr len ) 
VALUE SOURCE-ID 
VALUE SOURCE-POSITION \ readded for cf32 port (Samstag, August 13 2005 dbu)
\ Renamed ?LOADING to LOADING? because ?LOADING was defined as a variable
\ in older w32f versions (Dienstag, Oktober 03 2006 dbu).
CODE SP! ( addr -- ) 
\ set the data stack to point to addr
USER SP0 
CODE SP@ ( -- addr ) 
\ get addr, the pointer to the top item on data stack
: SPACE ( -- ) 
\ emit a space
: SPACES ( n -- ) 
\ emit n spaces
VALUE SPCS 
CONSTANT SPCS-MAX ( optimization for SPACES ) 
DEFER STACK-CHECK 
DEFER START-INCLUDE 
: START-INTERPRETER ( -- ) 
DEFER START/STOP 
VARIABLE STATE 
CODE STR= ( adr1 len1 adr2 len2 -- flag ) 
\ compares two strings, case sensitive, same as COMPARE 0=
: STRAND ( <-name-> -- ) 
\ new chain
VARIABLE SUPPRESS 
CODE SW@ ( a1 -- w1 ) 
\ fetch and sign extend the word (16bit) w1 from address a1
CODE SWAP ( n1 n2 -- n2 n1 ) 
\ exchange first and second items on data stack
: SYNONYM ( "newname" "oldname" -- ) 
\ 200X
\ Creates an alias of a word that will be immediate if the original word was
\ immediate.  The word order is the same as when making a colon definition.
\ <newname> is hidden during the search for <oldname> so that an alias of an
\ existing word in another vocabulary can be created (NOTE versions prior to
\ V6.10.05 and V6.11.10 incorrectly created a void definition when <newname>
\ was found in the search. If <oldname> is not found then <newname> remains
\ hidden (only since V6.10.05 and V6.11.10).
\ NOTE View of either name can go to the synonym instead (it depends which name
\ is found first in a full dictionary search).
: SYS-, ( n -- ) 
: SYS-ADDR? ( a -- f ) 
\ is it a system address?
: SYS-ALIGN ( -- ) 
: SYS-ALLOT ( n1 -- ) 
: SYS-C, ( n -- ) 
VARIABLE SYS-CHAIN-LINK \ linked list of system chains
: SYS-COMPILE ( -- ) 
: SYS-COMPILE, ( xt -- ) 
: SYS-FLOAD ( -<filename>- ) 
\ load "filename" into system dictionary
: SYS-FREE ( -- n1 ) 
: SYS-HERE ( -- a ) 
CONSTANT SYS-OFFS 
: SYS-ORIGIN ( -- a1 ) 
CONSTANT SYS-SIZE 
: SYS-W, ( n -- ) 
: SYS-WARN-DOES? ( newcode destxt -- ) 
: SYS-WARNING-OFF ( -- ) 
\ disable warning for use of system words in application
: SYS-WARNING-ON ( -- ) 
\ enable warning for use of system words in application
VALUE SYS-WARNING? 
: SYSTEM> ( -- ) 
\ back to previous DP  (synonym of DP>)
: TASK-CLEAR ( u -- ) 
\ Clear task-status bit.
ASSEMBLER TASK-ENTRY 
: TASK-FLIP ( u -- ) 
\ Toggle task-status bit.
: TASK-SET ( u -- ) 
\ Set task-status bit to true.
: TASK-STATUS? ( u -- f ) 
\ Test task-status bit.
USER TCB 
VALUE TEMP$ \ ptr to TEMP$
: THEN 
: THROW ( n -- ) 
\ throw an error, identified by n, while executing a word
\ whose execution is "protected" by CATCH .
VARIABLE THROW_MSGS 
: TIB ( -- addr ) 
: TO ( n -<value_name>- ) 
\ store n in a value. Ex: -1 TO myvalue
: TO ( n -<value_name>- ) 
\ store n in a value. Ex: -1 TO myvalue
CODE TOGGLE ( addr byte -- ) 
\ XOR the byte contents of "addr" with "byte"
CODE TR ( addr len table -- ) 
\ translate a buffer
CODE TRTNZ ( addr len table -- addr' len' code ) 
\ translate & test a buffer, stop at ~0
CODE TRTZ ( addr len table -- addr' len' ) 
\ translate & test a buffer, stop at =0
CONSTANT TRUE 
CODE TUCK ( n1 n2 -- n2 n1 n2 ) 
\ copy top data stack to under second item
: TURNKEYED? ( -- f ) 
\ return true if running as a Turnkey application
DEFER TYPE ( addr len -- ) 
( stdout: display string) 
: U. ( u -- ) 
\ display as unsigned single
: U.R ( u w -- ) 
\ display as unsigned single right justified in w wide field
CODE U2/ ( n1 -- n2 ) 
\ unsigned divide n1 by two
CODE U< ( u1 u2 -- f1 ) 
\ return true if unsigned u1 is less than
\ unsigned u2
CODE U> ( u1 u2 -- f1 ) 
\ return true if unsigned u1 is greater than
\ unsigned n2
CREATE UCASETAB \ uppercase a thru z to A thru Z
CODE UM* ( u1 u2 -- ud1 ) 
\ multiply unsigned u1 by unsigned u2
CODE UM/MOD ( ud1 u1 -- rem quot ) 
\ divide unsigned double ud1 by the
\ unsigned number u1
CODE UMAX ( u1 u2 -- n3 ) 
\ return the greater of unsigned u1 and
\ unsigned u2
CODE UMIN ( u1 u2 -- n3 ) 
\ return the lesser of unsigned u1 and
\ unsigned u2
CODE UN-LINK ( addr link -- f1 ) 
\ W32F        List
\ Unlink addr from list. f1 is 0 if addr was removed from list or non-zero if addr
\ wasn't in the list.
CODE UNDER+ ( a x b -- a+b x ) 
\ add top of stack to third stack item
DEFER UNLOAD-FORTH 
NCODE UNLOOP ( -- ) 
\ discard LOOP parameters from return stack
NCODE UNNEST ( -- ) 
\ exit the current Forth definition
NCODE UNNESTP ( -- ) 
\ exit the current Forth definition, remove parms
NCODE UNNESTP ( -- ) 
\ exit the current Forth definition, remove parms
: UNTIL 
CODE UP! ( addr -- ) 
\ set the pointer to the user area
CODE UP@ ( -- addr ) 
\ get the pointer to the user area
CODE UPC ( char -- char ) 
\ convert char to uppercase
: UPPER ( addr len -- ) 
\ translate string to uppercase
NCODE UPPERCASE ( str -- str ) 
\ translate to uppercase, but not '.' or '.
: USER ( n "name" -- ) 
\ create a user variable (changeable) value
CONSTANT USEREXTRA ( add to USERMIN if you are going to do I/O ) 
( *1 ) 
CONSTANT USERMIN ( absolute min user area ) 
CONSTANT USEROFFS ( user offset, 3 cells ) 
\ The following words are for altering the task-status bits so u should be a power of 2 representing
\ the relevant mask.
CONSTANT USERSIZE \ user area size for task variables
: VALUE ( n "name" -- ) 
\ create a self fetching changeable value
: VARIABLE ( "name" -- ) 
\ create a variable (changeable) value
OFFSET VCFA>VOC ( vocabulary-cfa -- voc-address ) 
CONSTANT VERSION# 
OFFSET VLINK>VOC ( voc-link-field -- voc-address ) 
: VOC#THREADS ( voc-address -- #threads ) 
DEFER VOC-ALSO 
VARIABLE VOC-LINK \ linked list of vocabularies
\ Vocabularies; currently, these MUST be defined as specified
OFFSET VOC>VCFA ( voc-address -- vocabulary-cfa ) 
OFFSET VOC>VLINK ( voc-address -- voc-link-field ) 
CODE W! ( w1 a1 -- ) 
\ store word (16bit) w1 into address a1
CODE W+! ( w1 a1 -- ) 
\ add word (16bit) w1 to the contents of address a1
: W, ( n -- ) 
( compile word at HERE, increment DP) 
CONSTANT W/O \ GENERIC_WRITE
CODE W@ ( a1 -- w1 ) 
\ fetch the word (16bit) w1 from address a1
: WAIT ( -- ) 
VARIABLE WARNING 
: WARNMSG ( n -- ) 
\ prints Warning:
CODE WCOUNT ( str -- addr len ) 
\ word (2 bytes) counted strings
: WHILE 
VARIABLE WINERRMSG 
VARIABLE WINLIB-LAST \ last library found/defined
VARIABLE WINLIB-LINK \ linkage for libraries
: WINLIBRARY ( 'name.DLL' -- ) 
\ usage: WINLIBRARY user32.dll
DEFER WINPAUSE ( -- ) 
\ release control to OS for a moment, pump the message loop
VARIABLE WINPROC-LAST \ last proc found/defined
VARIABLE WINPROC-LINK \ linkage for procedures
CODE WITHIN ( n1 low high -- f1 ) 
\ f1=true if ( (n1 >= low) and (n1 < high) )
CODE WORD ( char "<chars>ccc<char>" -- c-addr ) 
\ parse the input stream for a string delimited by char. Skip all leading char. Give a
\ counted string (the string is ended with a blank, not included in count).
\ If char is a blank treat all control characters as delimiter.
\ Use only inside colon definition.
CODE WORD-JOIN ( low high -- n1 ) 
\ join the high and low 16bit quantities
\ into a single 32bit n1
CODE WORD-SPLIT ( u1 -- low high ) 
\ split the unsigned 32bit u1 into its high
\ and low 16bit quantities.
: WRITE-FILE ( adr slen fileid -- ior ) 
\ ior = 0 = success
: WRITE-LINE ( adr len fileid -- ior ) 
CODE WSCAN ( adr len word -- adr' len' ) 
\ search first occurence of word "word" in string
CODE WSKIP ( adr len word -- adr' len' ) 
\ skip leading words "word" in string
CODE XOR ( n1 n2 -- n3 ) 
\ perform bitwise XOR of n1,n2, return result n3
: Z" ( -<string">- ) 
\ If compiling puts string in the dictionary
: Z", ( addr len -- ) 
\ W32F     String Extra
\ compile the string, addr len as uncounted chars at here
: Z," ( -<string">- ) 
\ compile string delimited by " as uncounted
\ chars null-terminated chars at here
CODE ZCOUNT ( str -- addr len ) 
\ null terminated string, whose 1rst char is at addr
DEFER [ 
: ['] ( "name" -- ) 
\ compile xt of "name" as a literal
: [CHAR] ( <c> -- char ) 
\ parse char from input stream and compile its
\ ASCII value as a literal
: [COMPILE] ( "name" -- ) 
\ compile the xt of word "name"
: \ ( -- ) 
DEFER \N->CRLF ( a1 n1 -- ) 
DEFER ] 
: _"OPEN ( a1 n1 -- fileid f1 ) 
\ open filename a1,n1
\ return fileid and f1=false=ok
NCODE _AGAIN ( -- ) 
\ "runtime" branch back to after BEGIN
NCODE _BEGIN ( -- ) 
\ "runtime" marker for the decompiler, a noop
NCODE _CASE ( -- ) 
\ "runtime" marker for the decompiler, a noop
VALUE _CONHNDL \ window handle for the original console handle
NCODE _ENDCASE ( n1 -- ) 
\ "runtime" discard n1 and continue
NCODE _ENDOF ( -- ) 
\ "runtime" branch to after ENDCASE
: _HEADER-OFA ( -- ) 
\ optional fields
: _INTERPRET ( -- ) 
NCODE _LOCALALLOC ( n1 -- a1 ) 
NCODE _LOCALALLOCP ( n1 -- a1 ) 
NCODE _LOCALFREE ( -- ) 
\ release local allocation
: _MESSAGE ( n -- ) 
\ prints Error:
: _NUMBER, ( d -- ) 
NCODE _OF ( n1 n2 -- [n1] ) 
\ "runtime"
\ if n1<>n2 branch to after ENDOF, return n1
\ else continue and don't return n1
: _PROC-ERROR ( addr -- ) 
NCODE _REPEAT ( -- ) 
\ "runtime" branch back to after BEGIN
: _RESET-STACKS ( ?? -- ) 
\ reset the stack
: _START/STOP ( -- ) 
NCODE _THEN ( -- ) 
\ "runtime" marker for the decompiler, a noop
NCODE _UNTIL ( f1 -- ) 
\ "runtime" if f1=FALSE branch to after BEGIN
NCODE _WHILE ( f1 -- ) 
\ "runtime" if f1=FALSE branch to after REPEAT
: _[ ( -- ) 
\ turn off compiling
: _] ( -- ) 
: { ( -- ) 
\ begin local variable usage in the form;
\ { initedloc1 initedloc2 \ uninitedloc3 -- comments }
: {: ( -- ) 
\ begin local variable usage in the form;
\ {: initedloc1 initedloc2 \ uninitedloc3 -- comments :}
: !$ ( n --; --; -- ) 
\ Moves the cursor-line to location n ( making it the "current location" )
: !C ( -- / n1) 
\ Returns the color of the current trace
: !CNCT ( n1 / -- ) 
\ Turns ON (n1<>0, or n1=TRUE) or OFF (n1=0 or n1=FALSE) linear connection between the points of the current trace
\ in the SpectraLab graph window.
: !COMMENT ( addr len / -- ) 
\ Replaces the Comment string with the string taken from the stack. Example of usage: s" New comment" @H
: !H ( addr len / -- ) 
\ Replaces the Header of the current trace (the thrace under line-cursor) with the string
\ taken from the stack. Example of usage: s" New title" @H
: !INTR ( n1 / -- ) 
\ Turns ON (n1<>0, or n1=TRUE) or OFF (n1=0 or n1=FALSE) interpolation between the points of the current trace
\ in the SpectraLab graph window.
: !M ( -- / n1 ) 
\ Returns the graphical display symbol of the current trace
: !SEL ( -- / -- ) 
\ Marks the current trace as selected for graphical display
: !X:: ( n1 n2 -- ; NEWY -- ; -- ) 
{ \ curloc# pt# mem# } 
: !Y:: ( n1 n2 -- ; NEWY -- ; -- ) 
{ \ curloc# pt# } 
: !Z ( -- ; Z -- ; -- ) 
\ Assigns the topmost value from the stack of reals to the "Z-value" associated with the current trace (trace under the cursor-line).
: !Z: ( n1 -- ; -- Z ; -- ) 
\ Assigns the topmost value from the stack of reals to the "Z-value" associated with the trace n1.
: #! ( n -- ; -- ; #A -- ) 
\ Places the trace from the top of the stack of traces into location #n
: #* \ An equivalent of #Y*
: #+ \ An equivalent of #Y+
: #- \ An equivalent of #Y-
: #/ \ An equivalent of #Y/
: #: ( n -- ; -- ; -- #n) 
\ Places the  trace #n into the stack of traces
: #ABSX ( -- ; -- ; #A -- #ABSX[#A] ) 
\ Calculates the absolute value of abscissa of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #ABSY ( -- ; -- ; #A -- #ABSY[#A] ) 
\ Calculates the absolute value of ordinate of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #AREA ( -- ; -- AREA[#A] ; #A -- ) 
\ Calculates the area under the curve for a given trace. The result is placed at the top of the stack of reals.
: #DEPTH ( -- n ; -- ; -- ) 
\ Returns the depth of the stack of traces (a number of traces in the stack)
: #DER \ DER is a synonym of #DER2
: #DER1 ( -- ; -- ; #A -- #DER1[#A] ) 
\ Calculates the first derivative of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #DER2 ( -- ; -- ; #A -- #DER1[#A] ) 
\ Calculates the second derivative of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #DROP ( -- ; -- ; #A -- ) 
\ Drops the topmost trace in the stack of traces
: #DUP ( -- ; -- ; #A -- #A #A ) 
\ Duplicates the trace at top of the stack of traces
: #EXPX ( -- ; -- ; #A -- #EXPX[#A] ) 
\ Calculates the exponential function of abscissa of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #EXPY ( -- ; -- ; #A -- #EXPY[#A] ) 
\ Calculates the exponential function of ordinate of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #INVERT 
: #LOGX ( -- ; -- ; #A -- #LOGX[#A] ) 
\ Calculates the natural logarithm of abscissa of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #LOGY ( -- ; -- ; #A -- #LOGY[#A] ) 
\ Calculates the natural logarithm of ordinate of the trace at the top of the stack of traces (the original trace is not changed).
\ The result is placed at the top of the stack.
: #MAXX ( -- ; -- MAXX[#A] ; #A -- ) 
\ Returns the maximal of all abscissa values of a given trace. The result is placed at the top of the stack of reals.
: #MAXY ( -- ; -- MAXY[#A] ; #A -- ) 
\ Returns the maximal of all ordinate values of a given trace. The result is placed at the top of the stack of reals.
: #MEAN ( -- ; -- MEAN[#A] ; #A -- ) 
\ Calculates the arithmetic mean of ordinate values of a trace. The result is placed at the top of the stack of reals.
: #MINX ( -- ; -- MINX[#A] ; #A -- ) 
\ Returns the minimal of all abscissa values of a given trace. The result is placed at the top of the stack of reals.
: #MINY ( -- ; -- MINY[#A] ; #A -- ) 
\ Returns the minimal of all ordinate values of a given trace. The result is placed at the top of the stack of reals.
: #OVER ( -- ; -- ; #A #B -- #A #B #A ) 
\ Copies the second trace from the top to the top of the stack
: #ROT ( -- ; -- ; #A #B #C -- #B #C #A) 
\ Rotates three traces at the top of the stack of traces
: #SEL ( -- / -- ) 
\ Marks the current trace as deselected for graphical display (hidden on the graph)
: #SMO ( <n> -- ; -- ; #A -- #SMO[#A] ) 
\ Performs polynomial smoothing of the trace at the top of the stack (the original trace is not changed).
\ The size of the moving window is taken from the stack of integers.
\ The window size may vary from 3 to 21 points. For the 3-points window, a second-order polynomial is used. In all other cases,
\ the smoothing is with a 3-rd order polynomial.
\ If the width of the smoothing window is not specified (the stack of integers is empty), the 5-point smoothing is applied.
\ The result is placed at the top of the stack.
: #SWAP ( -- ; -- ; #A #B -- #B #A ) 
\ Swaps two traces at the top of the stack of traces
: #TRI ( <n> -- ; -- ; #A -- #TRI[#A] ) 
\ Performs "triadic" (Tukey) smoothing of the trace at the top of the stack (the original trace is not changed).
\ The size of the moving window is taken from the stack of integers. The window size may vary from 3 to 7 points.
\ If the width of the smoothing window is not specified (the stack of integers is empty), the window of three points is used.
\ The result is placed at the top of the stack.
: #TRUNC ( -- ; FA -- ; #A -- #TRUNCY[#A,FA] ) 
\ "Truncates" the ordinata of trace #A at the value taken from the stack of reals (FA) in the meaning that
\ all values larger than FA will be replaced by FA
: #X* ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation multiples the abscisses of traces #A and #B.
\ Otherwise, it multiplies the abscissa of the trace at the top of the stack by the value taken from the stack of reals (F1)
: #X+ ( -- ; <F1> -- ; #A <#B> -- #C) 
\ If the stack of reals is empty, this operation adds the abscissa of trace #A to the abscissa of trace #B.
\ Otherwise, it adds the value taken from the stack of reals (F1) to the abscissa of the trace at the top of the stack.
: #X- ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation subtracts the abscissa of trace #A from the abscissa of trace #B.
\ Otherwise, it subtracts the value taken from the stack of reals (F1) from the abscissa of the trace at the top of the stack.
: #X/ ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation divides the abscissa of trace #B by the abscissa of trace #A.
\ Otherwise, it divides the abscissa of the trace at the top of the stack by the value taken from the stack of reals (F1)
: #Y* ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation multiples the ordinates of traces #A and #B.
\ Otherwise, it multiplies the ordinate of the trace at the top of the stack by the value taken from the stack of reals (F1)
: #Y+ ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation adds the ordinate of trace #A to the ordinate of trace #B.
\ Otherwise, it adds the value taken from the stack of reals (F1) to the ordinate of the trace at the top of the stack.
: #Y- ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation subtracts the ordinate of trace #A from the ordinate of trace #B.
\ Otherwise, it subtracts the value taken from the stack of reals (F1) from the ordinate of the trace at the top of the stack.
: #Y/ ( -- ; <F1> -- ; #A <#B> -- #C ) 
\ If the stack of reals is empty, this operation multiplies the ordinata of trace #B by the ordinata of trace #A.
\ Otherwise, it multiplies the ordinata of trace at the top of the stack by the value taken from the stack of reals (F1)
VALUE &I 
VALUE &J 
VALUE &K 
VALUE &NP 
VALUE &UU 
VALUE &ZZ 
: ?CLEARUP { clrref \ l } 
\ Deletes the current trace and all traces upwards of it. If "clrref" is FALSE (=0), the trace set as the
\ spectral reference is not deleted.
: ?SEL ( -- / n1 ) 
\ Returns TRUE (-1) if the current trace is selected for graphical display and FALSE (0) otherwise
: @C ( n1 / --) 
\ Sets the color of the current trace to that specified by the value taken from the stack (n1)
: @CNCT ( -- / n1 ) 
\ Returns the current settings of interpolation between the points of the current trace (0 if false, -1 if true).
\ in the SpectraLab graph window.
: @H ( -- / addr len ) 
\ Returns the header string of the current trace (the trace under line-cursor) as a pair of its
\ address and length
: @INTR ( -- / n1 ) 
\ Returns the current settings of interpolation between the points of the current trace (0 if false, -1 if true).
\ in the SpectraLab graph window.
: @M ( n1 / --) 
\ Sets the graphical display symbol of the current trace to that specified by the value taken from the stack (n1)
: @Z ( -- ; -- Z ; -- ) 
\ Returns the "Z-value" associated with the current trace (trace under the cursor-line). The result is placed at the top of the stack of reals.
: CLEAR ( n --; --; -- ) 
\ Deletes the current trace (the trace under the cursor-line) )
: CLEAR&KEEPZ ( -- \ -- ) 
\ Clears the current trace, but keeps the Z-value associated with it
: CLEARALL ( -- \ -- ) 
\ Deletes all traces in the memory
: CLEARUP ( -- \ -- ) 
\ Deletes the current trace and all traces upwards of it
: DELETE_POINT ( pnt-num \ boolean ) 
\ deletes the point specified by pnt-num from the curren trace. Returns TRUE if successful,
\ FALSE otherwise (if the specified point does not exist)
: DER ( -- ; -- ; -- ) 
\ DER is a synonym of DER2
: DER1 ( -- ; -- ; -- ) 
\ Calculates the first derivative of the current trace and REPLACES it with the result.
: DER2 ( -- ; -- ; -- ) 
\ Calculates the second derivative of the current trace and REPLACES it with the result.
: DESELECT ( n1 / -- ) 
\ Marks n1 traces starting at the current position as deselected for graphical display (hidden in the graph)
: EXPX ( -- ; -- ; -- ) 
\ Exponentiates the abscissa of the current trace and REPLACES it with the result.
: EXPY ( -- ; -- ; -- ) 
\ Exponentiates the ordinata of the current trace and REPLACES it with the result.
: LOGX ( -- ; -- ; -- ) 
\ Calculates the natural logarithm of abscissa of the current trace and REPLACES it with the result.
: LOGY ( -- ; -- ; -- ) 
\ Calculates the natural logarithm of ordinata of the current trace and REPLACES it with the result.
: SELECT ( n1 / -- ) 
\ Marks n1 traces starting at the current position as selected for graphical display
: X:: ( n1 n2 -- ; -- X[n1,n2] ; -- ) 
\ Returns the abscissa value of the point n2 from the trace n1. The result is placed at the top of the stack of reals.
CREATE XDELTA 
CREATE XEND 
CREATE XSTART 
: Y:: ( n1 n2 -- ; -- Y[n1,n2] ; -- ) 
\ Returns the ordinate value of the point n2 from the trace n1. The result is placed at the top of the stack of reals.
: Z: ( n1 -- ; -- Z ; -- ) 
\ Returns the "Z-value" associated with the trace n1. The result is placed at the top of the stack of reals.
: ~CLEARALL ( -- \ -- ) 
\ Deletes all traces in the memory
\ except the trace set as the spectral reference.
: ~CLEARUP ( -- \ -- ) 
\ Deletes the current trace and all traces upwards of it
\ except the trace set as the spectral reference.
CREATE &FTMP 
ZSTRING &TMP$ 
: . ( n1 / -- ) 
\ Synonim of ?i_ - redefines the standard "." function of WinForth
: ?F ( F1 / -- ) 
\ Types a floating point value and goes to the next line
: ?F_ ( F1 / -- ) 
( Types a floating point value in WinCRT window. The walue is taken from F-stack ) 
\ SpectraLab uses 10-byte reals (for compatibility with some instrument software )
: ?I ( n1 / -- ) 
\ Writes an integer and goes to the next line
: ?I_ ( n1 / -- ) 
\ Types an integer in WinCRT window. The value is taken from the stack of integers.
: ?S ( addr len / -- ) 
\ Types a string and goes to the next line
: CCR ( -- / -- ) 
\ Sends <Carriage Return> to WinCRT window (goes to the next line)
: CLEARCRT ( -- / -- ) 
\ Clears WinCRT window
: CR ( -- / -- ) 
\ Equivalent of CCR - redefines the standart CR function of WinForth
: CRT ( -- / -- ) 
\ Opens WinCRT window
: CRT_CLOSED ( -- / -- ) 
\ Checks the status of WinCRT window - returns TRUE if it is closed and FALSE othervise
: F. ( F1 / -- ) 
\ Synonim of ?i_ - redefines the standard "F." function of WinForth
: NOCRT ( -- / -- ) 
\ Closes WinCRT window
: TYPE$ ( addr len / -- ) 
\ Types a string in WinCRT window. The string is in the stack (addr len)
: XYTYPE$ ( addr len n1 n2 \ -- ) 
( Typees a string in WinCRT window at x and y coordinates given by n1 and n2) 
{ ix iy \ -- } 
PUSHBUTTON ADD-DATA-BTTN 
LABEL AUTO-COLHED 
PUSHBUTTON CLR-DATA-BTTN 
PUSHBUTTON CLR-SPC-BTTN 
TEXTBOX CMD-LINE 
TEXTBOX COLOR-EDIT 
TEXTBOX COMMENT-EDIT 
PUSHBUTTON CURSOR-BGN 
PUSHBUTTON CURSOR-DOWN 
PUSHBUTTON CURSOR-END 
PUSHBUTTON CURSOR-UP 
LABEL DATA-PAIR-LBL 
: DOSIZING ( -- ) 
INT DRAGGING? 
PUSHBUTTON EXEC-BUTTON 
PUSHBUTTON FOCUS-BGN 
PUSHBUTTON FOCUS-DOWN 
PUSHBUTTON FOCUS-END 
PUSHBUTTON FOCUS-UP 
LABEL FOOTTXT 
: GETPARMSITEM ( nItem  - Z$text Lparm flNew ) 
: GETPARMSITEM ( nItem  - Z$text Lparm flNew ) 
VOCABULARY GRAKERN 
GROUPBOX GROUP_DATA 
GROUPBOX GROUP_FOCUS 
GROUPBOX GROUP_LIST 
: HANDLELISTVIEWLEFT ( msg - ) 
: HANDLELISTVIEWRIGHT ( msg - ) 
: HEADERWIDTH 
TEXTBOX HED-EDIT 
LABEL HED-HED 
VALUE INIX 
VALUE INIY 
VALUE INPROCESS 
: INSPLITTER? ( -- f1 ) 
\ is cursor on splitter window
VOCABULARY INSTRUMENT 
CHECKBOX INT-ON 
VALUE ISNOTEDIT 
VALUE LAST-CHK 
VALUE LAST-EDT 
LABEL LBL-COLHED 
: LEFTHEIGHT ( -- n ) 
CHECKBOX LIN-ON 
INT LPARMLEFT 
LV_COLUMN LVC 
LABEL MAX-COLHED 
LABEL MIN-COLHED 
INT MOUSEDOWN? 
: MOVECURSOR { Newpos \ -- } 
: MOVEFOCUS { newobj \ -- } 
INT OBJ_ 
VALUE OLDOBJ 
: ON_CLICKED ( -- ) 
: ON_DBLCLICK ( -- ) 
: ON_UNCLICKED ( -- ) 
STRING: OUT$ 
CHECKBOX PLOT-ALL-CHK 
PUSHBUTTON PLOT-BUTTON 
GROUPBOX PLOT_AXES 
: POSITION-WINDOWS ( -- ) 
VOCABULARY REDEFINE 
VOCABULARY RESOURCES 
: RIGHTHEIGHT ( -- n ) 
VALUE SC-HGHT 
VALUE SC-WDTH 
VERTSCROLL SCROLLCURVELIST 
VERTSCROLL SCROLLDATASET 
CHECKBOX SEL-CHK 
INT SELECTEDITEMLEFT 
INT SELECTEDITEMRIGHT 
PUSHBUTTON SET-DATA-BTTN 
PUSHBUTTON SET-SPC-BTTN 
CHECKBOX SHOW-CURSOR 
VOCABULARY SPECARITHM 
VOCABULARY SPECTOOLS 
VOCABULARY SPECTRALAB 
VOCABULARY SPL32CRT 
VOCABULARY SPN_DEF 
TEXTBOX SYMBL-EDIT 
VALUE TURNKEY? \ 
\ Abstract
\ 
\ SpectraLab (SpLab) is a universal tool for advanced data analysis in
\ (bio)chemical spectroscopy and kinetics. The program is designed
\ to manipulate a set of up to 132 spectra (or kinetic traces,
\ or any other kind of two-dimensional data sets) simultaneously.
\ It allows for easy manipulations and arithmetic operations with
\ traces (add, subtract, divide, take a derivative, etc).
\ It also has utilities for smoothing, re-sampling (including
\ interpolation), automatic baseline correction and manual editing.
\ The spectral analysis section of SpectraLab includes
\ multi-dimensional least-square fitting algorithm, which
\ allows approximating a spectrum with a linear combination
\ of spectral standards (spectral prototypes) and a
\ polynomial. This feature allows for quantitative determination of
\ concentrations  of individual components in  a mixture. The program
\ also includes the Principal Component Analysis (PCA) engine,
\ which is used in global analysis of spectral changes
\ in series of spectra obtained in spectral titrations, kinetic
\ experiments, etc. It allows for automatic correction of
\ changes in turbidity, absorbance of the titrant, or
\ fluctuation of the baseline during the experiment.
\ Program also incorporates non-linear least
\ regression routines based on Marquardt and Nelder-Mead
\ algorithms. It allows fitting of the data sets (including
\ global fitting of three-dimensional data sets) to various predefined
\ functions, such as Michaelis-Menten, Hill, or "Tight-Binding"
\ equations, sum of exponents, second order kinetic equation, etc.
\ The package thus includes most of the mathematical tools needed
\ in the routine work in biochemical spectroscopy and enzyme
\ kinetics. The program is menu-driven and (mostly) self-explanatory.
\ In addition, the software also implements a powerful, Forth-based scripting
\ language.
\ Besides the stand-alone version, the software is also available in
\ several instrument-specific versions incorporating instrument control
\ and data aquisition functions for the following instruments:
( Ocean Opics CCD spectrometer ) 
( Edinbourgh Instruments EI-900 fluorometer ) 
( Modified PTI QM-1 fluorometer ) 
\ equipped with a Hammamatsu H9059 photon-counting
\ photomultipler module and a USB-CTR04 high-speed
\ counter/timer module (Measurement Computing Corporation).
( Hitachi F2000 fluorometer ) 
VOCABULARY UTILITIES 
: VERSTITLE 
VALUE WMCOMMAND-FUNC \ function pointer for WM_COMMAND
CHECKBOX X-AUTO 
TEXTBOX X-EDIT 
LABEL X-HED 
TEXTBOX X-LABL-EDIT 
LABEL X-LINHED 
TEXTBOX X-MAX-EDIT 
TEXTBOX X-MIN-EDIT 
LABEL X-VALUE-LBL 
CHECKBOX Y-AUTO 
TEXTBOX Y-EDIT 
LABEL Y-HED 
TEXTBOX Y-LABL-EDIT 
LABEL Y-LINHED 
TEXTBOX Y-MAX-EDIT 
TEXTBOX Y-MIN-EDIT 
LABEL Y-VALUE-LBL 
TEXTBOX Z-EDIT 
LABEL Z-HED 
